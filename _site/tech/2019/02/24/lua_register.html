<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>浅析C++与Lua数据交互层 | Stupid bird</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="浅析C++与Lua数据交互层" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="背景" />
<meta property="og:description" content="背景" />
<link rel="canonical" href="http://localhost:4000/tech/2019/02/24/lua_register.html" />
<meta property="og:url" content="http://localhost:4000/tech/2019/02/24/lua_register.html" />
<meta property="og:site_name" content="Stupid bird" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-24T18:13:00+08:00" />
<script type="application/ld+json">
{"description":"背景","@type":"BlogPosting","url":"http://localhost:4000/tech/2019/02/24/lua_register.html","headline":"浅析C++与Lua数据交互层","dateModified":"2019-02-24T18:13:00+08:00","datePublished":"2019-02-24T18:13:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/tech/2019/02/24/lua_register.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Stupid bird" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Stupid bird</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">浅析C++与Lua数据交互层</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-02-24T18:13:00+08:00" itemprop="datePublished">Feb 24, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="背景">背景</h2>

<p>​	C++作为服务器端开发的主流语言，相比其他语言有明显的性能优势，但是它的技术门槛比较高，不支持热更新，无法进行迅速的需求迭代和线上问题的响应。另外，C++内存管理的特点，技术人员对指针的使用不当，可能会造成宕机。因此，现在越来越多的技术团队会选择在C++中嵌入脚本语言，C++提供底层支持，脚本语言进行业务逻辑的开发。这样的好处，一方面将开发人员进行划分，C++代码的维护只由核心人员进行。业务层的脚本代码开发，相对比较简单，可以交由经验比较浅的新人，甚至外包给其他团队；另外一方面，脚本语言的灵活性，可热更新，又弥补了C++的不足。</p>

<p>​	Lua作为一门非常轻量的脚本语言，被大量的游戏团队使用。我们就来说一说，C++是如何与Lua进行数据交互的。</p>

<p>​	已有的类似系统有LuaBinder、LuaTinker、CppToLua等。</p>

<h2 id="基本原理">基本原理</h2>

<p>​	Lua提供了虚拟栈的概念，C/C++可以通过push/pop从栈上逐一存取基本的数据类型，也可以通过pushcfunction/pushcclosure，将函数注册给Lua，供其调用。但对于C++来说，数据结构比较复杂，有类和对象的概念，类有成员变量和成员函数，类之间又有继承的关系。Lua的基本接口并无法支撑这么复杂的数据交互。我们要实现的数据交互层，就是为C++提供一套注册接口，方面将C++中的类、对象类型的变量、类的成员变量和成员函数注册到Lua中去，让Lua像访问原生数据一样访问它们。</p>

<p>​       如下，在C++中定义了如下类A，并利用数据交互层提供的接口，将A类的成员变量和成员函数注册给Lua。然后，将A类型的对象ca注册到Lua的全局变量中，为了进行区分，命名为la。在Lua代码里，就可以通过la.x访问对象ca.x的变量，通过la:funcA(p1,p2,…)调用ca.funcA的函数了。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">();</span>
    <span class="o">~</span><span class="n">A</span><span class="p">();</span>
    
    <span class="n">TypeX</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">TypeY</span> <span class="n">funcA</span><span class="p">(</span><span class="n">Param1</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Param2</span> <span class="n">p2</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="n">registerClass</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span> <span class="c1">// L 为lua_State*类型</span>
<span class="n">registerClassFunction</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"funcA"</span><span class="p">,</span> <span class="n">A</span><span class="o">::</span><span class="n">funcA</span><span class="p">);</span>
<span class="n">registerClassMemberVariable</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">x</span><span class="p">);</span>

<span class="n">A</span> <span class="n">ca</span><span class="p">;</span>
<span class="n">registerVariable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"la"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca</span><span class="p">);</span>
</code></pre></div></div>

<p>​	这背后的发生了什么？先来看一下<code class="highlighter-rouge">regiserClass</code>的实现，在Lua的全局环境中注册了名为name的表，并定义几个元方法，我们称这种表为类表。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">registerClass</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ClassName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">//注册类名</span>
    
    <span class="n">lua_newtable</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__name"</span><span class="p">);</span>
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__index"</span><span class="p">);</span>
    <span class="n">lua_pushcclosure</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">meta_get</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__newindex"</span><span class="p">);</span>
    <span class="n">lua_pushcclosure</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">meta_set</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__gc"</span><span class="p">);</span>
    <span class="n">lua_pushcclosure</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">destroyer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">lua_setglobal</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当访问la.x时，会把la当作table，寻找table中key为”x”的值。la.x当作左值时会触发 <code class="highlighter-rouge">__newindex</code>元方法，当作右值时会触发 <code class="highlighter-rouge">__index</code>元方法。当la中没有找到key为”x”的值，就会去la的元表中进行查找。因此，需要将la的元表设置为A的类表。</p>

<p>​	除了上面通过注册全局变量，Lua层还有另外两个途径访问C++类的对象：通过C++类的构造函数直接构造对象、通过其他对象的成员变量或者成员函数的返回值。三种途径的关键一步，都是将userdata的元表关联到注册给Lua的类表中。</p>

<h3 id="一层数据封装">一层数据封装</h3>

<p>​	Lua中的基本数据类型有number、string、table、function、userdata、thread。la本质上就是userdata，指向内存数据的一个指针，简单理解，可以认为是对象实例ca的地址，实际上，进行了一层封装。分别定义了ValueToUser<T>、PtrToUser<T>、RefToUser<T>三种类型，来处理值类型、指针类型和引用类型，它们都继承自UserBase。这样就可以将任意类型的值、指针、引用压入Lua虚拟栈中。注意到ValueToUser需要负责类型的创建和删除，PtrToUser和RefToUser只是持有对象的地址。</T></T></T></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">UserBase</span>
<span class="p">{</span>
    <span class="n">UserBase</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span> <span class="n">m_p</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">UserBase</span><span class="p">();</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">m_p</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ValueToUser</span><span class="o">:</span> <span class="n">UserBase</span>
<span class="p">{</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
	<span class="n">ValueToUser</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">UserBase</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span> <span class="p">{}</span>
	
	<span class="o">~</span><span class="n">ValueToUser</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">((</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">m_p</span><span class="p">);}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">PtrToUser</span><span class="o">:</span> <span class="n">UserBase</span>
<span class="p">{</span>
	<span class="n">PtrToUser</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span><span class="o">:</span> <span class="n">UserBase</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RefToUser</span><span class="o">:</span> <span class="n">UserBase</span>
<span class="p">{</span>
	<span class="n">RefToUser</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span><span class="o">:</span> <span class="n">UserBase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

</code></pre></div></div>

<p>注意到registerClass中将destroyer<T>函数注册为__gc元方法，当Lua产生垃圾回收时，就会调用该方法：</T></p>

<pre><code class="language-C++">template&lt;typame T&gt;
int destroyer(lua_State* L)
{
    ((UserBase*)lua_touserdata(L, -1))-&gt;~UserBase();
    return 0; //告诉Lua该函数没有返回值
}
</code></pre>

<h3 id="两个抽象操作">两个抽象操作</h3>

<p>定义两个操作：pushToLuaStack<T>可以将任意类型的数据压入Lua虚拟栈，getFromLuaStack<T>则可以从Lua虚拟栈中取出任意类型的数据。</T></T></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushToLuaStack&lt;T&gt;
				|
                | EnumToLua&lt;T&gt; ---&gt; 将number类型压入栈
                | ObjectToLua&lt;T&gt; ---&gt; | ValueToLua&lt;T&gt; ---&gt; 将ValueToUser&lt;T&gt;类型入栈
                                      | PtrToLua&lt;T&gt;   ---&gt; 将PtrToUser&lt;T&gt;类型入栈
                                      | RefToLua&lt;T&gt;   ---&gt; 将RefToUser&lt;T&gt;类型入栈 
                                      &amp; 将T的类表作为刚压入栈的userdata的元表
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getFromLuaStack&lt;T&gt;
                |
                | LuaToEnum&lt;T&gt; ---&gt; 从栈上取出number类型变量
				| LuaToObject&lt;T&gt; ----&gt; &amp; 1. user = LuaUserDataToType&lt;UserBase*&gt;::convert()
						               &amp; 2. VoidToType&lt;T&gt;(user-&gt;m_p)
						                           |
						                           | T如果是指针类型，VoidToPtr
						                           | T如果是引用类型，VoidToRef
						                           | T如果是值类型，  VoidToValue
</code></pre></div></div>

<h3 id="注册成员变量">注册成员变量</h3>

<p>​	<code class="highlighter-rouge">registerClassMemberVariable&lt;A&gt;(L, "x", &amp;A::x)</code>在类表中注册了key为”x”的键值对，值是一个void* 类型的userdata，实际是一个VariableBase类型的指针，利用运行时多态和模板，是可以达到反射的目的的。把任意类的任意成员变量，都抽象成VariableBase类，它只有两个虚函数接口，get用来把成员变量的值压入栈中，set用来取出栈上的值并赋给成员变量。VariableBase根据T和V派生出MemberVariable&lt;T, V&gt;类。MemberVariable&lt;T, V&gt;记录了成员变量在类中的偏移地址，同时具现了get和set这两个接口，因为有类型信息，可以知道从栈上取出是什么类型的值。</p>

<pre><code class="language-C++">struct VariableBase
{
    virtual void get(lua_State* L) = 0;
    virtual void set(lua_State* L) = 0;
};

template&lt;typename T, typename V&gt;
MemberVariable: VariableBase
{
	V T::*_var;
	
	void get(lua_State* L)
    {
    	pushToLuaStack&lt;V&gt;(L, getFromLuaStack&lt;T*&gt;(L, 1)-&gt;*(_var));  //从栈底取出对象地址偏移到成员变量所在地址，将成员变量值压入栈中
    }
    
    void set(lua_State* L)
    {
    	getFromLuaStack&lt;T*&gt;(L, 1)-&gt;*(_var) = getFromLuaStack&lt;V&gt;(L, 3);
    }
};

int meta_get(lua_State* L)
{
    lua_getmetatable(L, 1); // 将栈底的元表压栈，例子中就是la的类表A
    lua_pusvalue(L, 2);     // 将栈底上面的元素，就是key复制压入栈；例子中就是"x"
    lua_rawget(L, -2);      // 得到A[x]的值
    
    if(lua_isuserdata(L, -1))
    {
        LuaUserDataToType&lt;VariableBase*&gt;::convert(L, -1)-&gt;get(L); //将栈底的userdata转
        lua_remove(L, -2); // 将类表移出栈
    }
    ...
}

int meta_set(lua_State* L)
{
    lua_getmetatable(L, 1); // 将栈底的元表压栈，例子中就是la的类表A
    lua_pusvalue(L, 2);     // 将栈底上面的元素，就是key复制压入栈；例子中就是"x"
    lua_rawget(L, -2);      // 得到A[x]的值
    
    if(lua_isuserdata(L, -1))
    {
        LuaUserDataToType&lt;VariableBase*&gt;::convert(L, -1)-&gt;set(L);
    }
    ...
    lua_settop(L, 3);
}
</code></pre>

<h3 id="注册成员函数">注册成员函数</h3>

<p>​	<code class="highlighter-rouge">registerClassFunction&lt;A&gt;(L, "funcA", A::funcA)</code>做了什么？在类表中注册了key为”funcA”的键值对，值是一个闭包。<code class="highlighter-rouge">lua_pushcclosure(L，func, n)</code>函数允许将一个函数func压入栈的同时，指定它之前栈上的n个元素作为upvalue，这就是闭包的概念。这里的闭包是模版类MemberFunctionDelegate&lt;Ret, T, …Args&gt;的静态函数——call函数，upvalue是A::funcA的函数指针。模板类通过模板参数，将所属类T，返回值类型Ret，以及函数的参数列表的类型都记录下来。当la:funcA调用时，实际调用的是<code class="highlighter-rouge">MemberFunctionDelegate&lt;Ret, T, …Args&gt;::call</code>函数，Lua会将la(指向ca的指针)和函数的参数依次压入栈中。call的实现，首先从upvalue中取出成员函数指针，再从栈低到栈顶依次取出，ca的地址和A::funcA的各个参数，有了这些，就能真正地调用ca:funcA(p1,p2,…)，并将函数的返回值压入栈。</p>

<pre><code class="language-C++">template&lt;typename RVal, typename T, typename ... Args&gt;
struct MemberFunctionDelegate
{
    static int call(lua_State* L)
    {
        typedef RVal(T::*MemFunc)(Args ...);
        MemFunc fun = getUpValue&lt;MemFunc&gt;(L); // 从upvalue中取出成员函数指针
        
        int index = 1;
        T* t = getFromLuaStack&lt;T*&gt;(L, index++); //从栈底取出对象地址
        pushToLuaStack(L, (t-&gt;*fun)(getFromLuaStack&lt;Args&gt;(L, index++)...));
        
        return 1;
    }
};

template&lt;typename RVal, typename T, typename ... Args&gt;
pushFunctionDelegate(lua_State* L, RVal(T::*func)(Args...))
{
    lua_pushcclosure(L, MemberFunctionDelegate&lt;RVal, T, Args...&gt;::call, 1);
}

template&lt;typename T, typename F&gt;
void registerClassFunction(lua_State* L, const char* name, F func)
{
    push_meta(L, ClassName&lt;T&gt;::name());  // 将T的类表压入栈
    if(lua_istable(L, -1))
    {
        lua_pushstring(L, name);
        new(lua_newuserdata(L, sizeof(F))) F(func); //成员函数指针作为upvalue
        pushFunctionDelegate(L, func); 
        lua_rawset(L, -3);
    }
    lua_pop(L, 1);
}
</code></pre>

<h3 id="注册构造函数">注册构造函数</h3>

<p>当我们在Lua中将表当作构造表达式使用时，例如t = T(…)，就会调用T的__call元方法。通过下面代码可以看到，注册的构造函数，其实创建了一个ValueToUser<T>类型的userdata，并将它的元表设为T的类表。</T></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">constructor</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">new</span><span class="p">(</span><span class="n">lua_newuserdata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueToUser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)))</span> <span class="n">ValueToUser</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getFromLuaStack</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)...);</span>
    <span class="n">push_meta</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">ClassName</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ClassType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">name</span><span class="p">());</span>
    <span class="n">lua_setmetatable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">addClassConstructor</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">F</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">push_meta</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">ClassName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">name</span><span class="p">());</span>
    <span class="k">if</span><span class="p">(</span><span class="n">lua_istable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">lua_newtable</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
        <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__call"</span><span class="p">);</span>
        <span class="n">lua_pushcclosure</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">lua_setmetatable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 注册构造函数示例</span>
<span class="n">addClassConstrutor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">constructor</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Lua中创建A对象示例</span>
<span class="n">la</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="注册继承关系">注册继承关系</h3>

<p>C++中定义如下两个类A和B，B继承自A。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="o">~</span><span class="n">A</span><span class="p">();</span>
    
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">TypeY</span> <span class="n">funcA</span><span class="p">(</span><span class="n">Param1</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Param2</span> <span class="n">p2</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">};</span>

<span class="n">Class</span> <span class="n">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="o">~</span><span class="n">B</span><span class="p">();</span>
    
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">TypeW</span> <span class="n">funcB</span><span class="p">(</span><span class="n">Param</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Param2</span> <span class="n">p2</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">};</span>

</code></pre></div></div>

<p>通过数据交互层提供的接口，不仅可以注册类的成员变量和成员函数，还可以将继承关系继承到Lua中。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">registerClass</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span> <span class="c1">// L 为lua_State*类型</span>
<span class="n">registerClassFunction</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"funcA"</span><span class="p">,</span> <span class="n">A</span><span class="o">::</span><span class="n">funcA</span><span class="p">);</span>
<span class="n">registerClassMemberVariable</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">x</span><span class="p">);</span>

<span class="n">registerClass</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"B"</span><span class="p">);</span>
<span class="n">registerClassFunction</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"funcB"</span><span class="p">,</span> <span class="n">B</span><span class="o">::</span><span class="n">funcB</span><span class="p">);</span>
<span class="n">registerClassMemberVariable</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"z"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">B</span><span class="o">::</span><span class="n">z</span><span class="p">);</span>
<span class="n">inherientClass</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

<span class="n">A</span> <span class="n">ca</span><span class="p">;</span>
<span class="n">registerVariable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"la"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca</span><span class="p">);</span>
</code></pre></div></div>

<p>于是在Lua脚本中，通过实例lb不仅可以访问类B的成员变量和函数，可以访问其父类的。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lb</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="nb">print</span><span class="p">(</span><span class="n">lb</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
<span class="n">lb</span><span class="p">:</span><span class="n">funcB</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="nb">print</span><span class="p">(</span><span class="n">lb</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="n">lb</span><span class="p">:</span><span class="n">funcA</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</code></pre></div></div>

<p>这种继承关系，是如何注册到Lua中去的？</p>

<p>看看inherientClass函数的实现：本质上就是将一个类表的__parent指向了父类表。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">inherientClass</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">push_meta</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">ClassName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">name</span><span class="p">());</span>
    <span class="k">if</span><span class="p">(</span><span class="n">lua_istable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__parent"</span><span class="p">);</span>     <span class="c1">// 通过__parent元方法，奖励两个类表之间的“继承”关系</span>
        <span class="n">push_meta</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">ClassName</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;::</span><span class="n">name</span><span class="p">());</span>
        <span class="n">lua_rawset</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们再来看一下完整的meta_get和meta_set函数实现，当在当前类表中查找不到键值对时，就会调用invoke_parent函数，递归地从继承关系链中，向上搜寻父类表或者祖先类表中是否存在键值对。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">invoke_parent</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"__parent"</span><span class="p">);</span>  <span class="c1">// 取出继承关系中的父类表</span>
    <span class="n">lua_rawget</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">lua_istable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>   <span class="c1">// 如果存在父类表</span>
    <span class="p">{</span>
        <span class="n">lua_pushvalue</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//将栈底上面的元素，即要找的key复制入栈</span>
        <span class="n">lua_rawget</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">// 尝试从父类表中找到key对应的value是否存在</span>
        
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//如果找到，将父类表移除</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//将栈顶的nil移除</span>
            <span class="n">invoke_parent</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>  <span class="c1">//递归调用在父类的父类中查找</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//将父类表移除</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">meta_get</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lua_getmetatable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//将栈底元素的元表入栈</span>
    <span class="n">lua_pushvalue</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// 复制key并压入栈</span>
    <span class="n">lua_rawget</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>      <span class="c1">// 获取元表[key]的值</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">lua_isuserdata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1">//如果是userdata</span>
    <span class="p">{</span>
        <span class="n">LuaUserDateToType</span><span class="o">&lt;</span><span class="n">VariableBase</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="c1">//将成员变量的值压入栈</span>
        <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// 将userdata移除</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//将nil值从栈顶移除</span>
        <span class="n">invoke_parent</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>  <span class="c1">// 从父元表中查找</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">lua_isuserdata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> 
        <span class="p">{</span>
            <span class="n">LuaUserDataToType</span><span class="o">&lt;</span><span class="n">VariableBase</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">lua_pushfstring</span><span class="p">(</span><span class="s">"Fogot registering '%s' class variable?"</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
            <span class="n">lua_error</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 将元表移除</span>
        
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 提示栈上有数据返回</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">meta_set</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lua_getmetatable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//将栈底元素的元表入栈</span>
    <span class="n">lua_pushvalue</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// 复制key并压入栈</span>
    <span class="n">lua_rawget</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>      <span class="c1">// 获取元表[key]的值</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">lua_isuserdata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1">//如果是userdata</span>
    <span class="p">{</span>
        <span class="n">LuaUserDateToType</span><span class="o">&lt;</span><span class="n">VariableBase</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="c1">//成员变量赋值</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//将nil值从栈顶移除</span>
        <span class="n">invoke_parent</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>  <span class="c1">// 从父元表中查找</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">lua_isuserdata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> 
        <span class="p">{</span>
            <span class="n">LuaUserDataToType</span><span class="o">&lt;</span><span class="n">VariableBase</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">lua_pushfstring</span><span class="p">(</span><span class="s">"Fogot registering '%s' class variable?"</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
            <span class="n">lua_error</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">lua_settop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> 
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


  </div><a class="u-url" href="/tech/2019/02/24/lua_register.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Stupid bird</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Stupid bird</li><li><a class="u-email" href="mailto:dreamfly_lin@126.com">dreamfly_lin@126.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/thinkbed"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">thinkbed</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Something to be recorded...</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
